<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: query/condition/ConditionParser.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: query/condition/ConditionParser.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

require('insulin').factory('ndm_ConditionParser',
  ['ndm_ConditionError'], ndm_ConditionParserProducer);

function ndm_ConditionParserProducer(ConditionError) {
  /** A recursive decent parser for a SQL condition (WHERE or ON).
  This parser takes in a set of tokens, as generated by the
  ConditionLexer.parse method, and makes sure that the condition is valid.  If
  the condition sentence does not match the condition grammer, an exception is
  raised.  Otherwise, a parse tree is created. */
  class ConditionParser {
    /**
     * Parse the tokens (as an object) and return a parse tree.  The condition
     * must follow the following grammar.
     *
     * &lt;pre>
     *   &amp;lt;condition&amp;gt;                ::= "{" &amp;lt;comparison&amp;gt; | &amp;lt;null-comparison&amp;gt; | &amp;lt;in-comparison&amp;gt; | &amp;lt;logical-condition&amp;gt; "}"
     *   &amp;lt;comparison&amp;gt;               ::= &amp;lt;comparison-operator&amp;gt; ":" "{" &amp;lt;column&amp;gt; ":" &amp;lt;value&amp;gt; "}"
     *   &amp;lt;null-comparison&amp;gt;          ::= &amp;lt;null-comparison-operator&amp;gt; ":" "{" &amp;lt;column&amp;gt; ":" &amp;lt;nullable&amp;gt; "}"
     *   &amp;lt;in-comparison&amp;gt;            ::= &amp;lt;in-comparison-operator&amp;gt; ":" "{" &amp;lt;column&amp;gt; ":" "[" &amp;lt;value&amp;gt; {"," &amp;lt;value&amp;gt;} "]" "}"
     *   &amp;lt;logical-condition&amp;gt;        ::= &amp;lt;boolean-operator&amp;gt; ":" "[" &amp;lt;condition&amp;gt; {"," &amp;lt;condition&amp;gt;} "]"
     *   &amp;lt;comparison-operator&amp;gt;      ::= "$eq" | "$neq" | "$lt" | "$lte" | "$gt" | "$gte" | "$like" | "$notlike"
     *   &amp;lt;in-comparison-operator&amp;gt;   ::= "$in" | "$notIn"
     *   &amp;lt;null-comparison-operator&amp;gt; ::= "$is" | "$isnt"
     *   &amp;lt;boolean-operator&amp;gt;         ::= "$and" | "$or"
     *   &amp;lt;nullable&amp;gt;                 ::= null | &amp;lt;parameter&amp;gt;
     *   &amp;lt;value&amp;gt;                    ::= &amp;lt;parameter&amp;gt; | &amp;lt;column&amp;gt; | &amp;lt;number&amp;gt; | null
     *   &amp;lt;column&amp;gt;                   ::= &amp;lt;string&amp;gt;
     *   &amp;lt;parameter&amp;gt;                ::= :&amp;lt;string&amp;gt;
     * &lt;/pre>
     *
     * @param {Object[]} tokens - An array of tokens, as created by the
     * ConditionLexer.parse method.
     * @return {Object} A parse tree.  Each node in the tree has a token and
     * children nodes.
     */
    parse(tokens) {
      this._tokenInd = 0;
      this._tokens   = tokens;
      this._token    = this._tokens[this._tokenInd];
      this._tree     = null;
      this._curNode  = null;

      // Parse the program, and return the resulting parse tree.
      this._condition();

      if (this._token !== null)
        throw new ConditionError(this._errorString('EOL'));

      return this._tree;
    }

    // &lt;condition> ::= "{" &lt;comparison> | &lt;null-comparison> | &lt;in-comparison> | &lt;logical-condition> "}"
    _condition() {
      const pairParts = ['comparison-operator', 'null-comparison-operator', 'in-comparison-operator', 'boolean-operator'];

      this._charTerminal('{');
      
      if (!this._tokenIn(pairParts))
        throw new ConditionError(this._errorString('[' + pairParts.join(' | ') + ']'));

      if (this._token.type === 'comparison-operator')
        this._comparison();
      else if (this._token.type === 'null-comparison-operator')
        this._nullComparison();
      else if (this._token.type === 'in-comparison-operator')
        this._inComparison();
      else
        this._logicalCondition();

      this._charTerminal('}');
    }

    // &lt;comparison> ::= &lt;comparison-operator> ":" "{" &lt;column> ":" &lt;value> "}"
    _comparison() {
      this._comparisonOperator();
      this._charTerminal(':');
      this._charTerminal('{');
      this._column();
      this._charTerminal(':');
      this._value();
      this._charTerminal('}');
    }

    // &lt;in-comparison> ::= &lt;in-comparison-operator> ":" "{" &lt;column> ":" "[" &lt;value> {"," &lt;value>} "]" "}"
    _inComparison() {
      this._inComparisonOperator();
      this._charTerminal(':');
      this._charTerminal('{');
      this._column();
      this._charTerminal(':');
      this._charTerminal('[');
      this._value();
      while (this._token.value === ',') {
        this._charTerminal(',');
        this._value();
      }
      this._charTerminal(']');
      this._charTerminal('}');
    }

    // &lt;null-comparison> ::= &lt;null-comparison-operator> ":" "{" &lt;column> ":" &lt;nullable> "}"
    _nullComparison() {
      this._nullComparisonOperator();
      this._charTerminal(':');
      this._charTerminal('{');
      this._column();
      this._charTerminal(':');
      this._nullable();
      this._charTerminal('}');
    }

    // &lt;logical-condition> ::= &lt;boolean-operator> ":" "[" &lt;condition> {"," &lt;condition>} "]"
    _logicalCondition() {
      this._booleanOperator();
      this._charTerminal(':');
      this._charTerminal('[');
      this._condition();
      // &lt;boolean-operator> is preceded by an array of &lt;condition>.  After adding each
      // &lt;condition> node make the &lt;boolean-operator> the current node.
      this._curNode = this._curNode.parent;
      while (this._token &amp;&amp; this._token.value === ',') {
        this._charTerminal(',');
        this._condition();
        this._curNode = this._curNode.parent;
      }
      this._charTerminal(']');
    }

    // &lt;comparison-operator> ::= "$eq" | "$neq" | "$lt" | "$lte" | "$gt" | "$gte"
    _comparisonOperator() {
      this._matchType('comparison-operator');
    }

    // &lt;in-comparison-operator> ::= "$in" | "$notIn"
    _inComparisonOperator() {
      this._matchType('in-comparison-operator');
    }

    // &lt;null-comparison-operator> ::= "$is" | "$isnt"
    _nullComparisonOperator() {
      this._matchType('null-comparison-operator');
    }

    // &lt;boolean-operator> ::= "$and" | "$or"
    _booleanOperator() {
      this._matchType('boolean-operator');
    }

    // &lt;nullable> ::= null | &lt;parameter>
    _nullable() {
      const values = ['null', 'parameter'];
      
      if (!this._tokenIn(values))
        throw new ConditionError(this._errorString('[' + values.join(' | ') + ']'));

      if (this._token.type === 'null')
        this._nullTerminal();
      else
        this._parameter();
    }

    // &lt;value> ::= &lt;parameter> | &lt;column> | &lt;number>
    _value() {
      const values = ['parameter', 'column', 'number'];
      
      if (!this._tokenIn(values))
        throw new ConditionError(this._errorString('[' + values.join(' | ') + ']'));

      if (this._token.type === 'parameter')
        this._parameter();
      else if (this._token.type === 'column')
        this._column();
      else
        this._number();
    }

    // &lt;parameter> ::= :&lt;string>
    _parameter() {
      this._matchType('parameter');
    }

    // &lt;column> ::= &lt;string>
    _column() {
      this._matchType('column');
    }

    // Number terminal.
    _number() {
      this._matchType('number');
    }

    // Handles non-characters.  Verifies that the current token's type matches
    // the passed-in type.  If not, an exception is raised.  If so, the token is
    // advanced.
    _matchType(type) {
      if (this._token === null || this._token.type !== type)
        throw new ConditionError(this._errorString(`&lt;${type}>`));

      this._addNode();
      this._advance();
    }

    // Handles the basic character terminals, which aren't needed in the
    // resulting sentence/tree.  These are the basic terminals: "{", "}", "[",
    // "]", ":", ","
    _charTerminal(c) {
      if (this._token === null || c !== this._token.value)
        throw new ConditionError(this._errorString(c));

      this._advance();
    }

    // Checks that the current token is a null terminal.
    _nullTerminal() {
      if (this._token === null || this._token.type !== 'null')
        throw new ConditionError(this._errorString('null'));

      this._addNode();
      this._advance();
    }

    // Move to the next token, or set token to null if the end of the sentence is
    // encountered.
    _advance() {
      if (this._tokenInd >= this._tokens.length)
        throw new ConditionError('Encountered the end of the sentence prematurely.');

      if (++this._tokenInd &lt; this._tokens.length)
        this._token = this._tokens[this._tokenInd];
      else
        this._token = null;
    }

    // Check if the current token matches one of the types on toks.
    _tokenIn(tokTypes) {
      return tokTypes.some(function(type) {
        return this._token.type === type;
      }, this);
    }

    // Helper to create an error string.
    _errorString(expected) {
      const type  = this._token ? this._token.type  : 'EOL';
      const value = this._token ? this._token.value : 'EOL';

      return `At index ${this._tokenInd}.  Expected ${expected} but found type ` +
             `${type} with value ${value}.`;
    }

    // Helper function to add a node to the parse tree.
    _addNode() {
      const node = {
        children: [],
        parent:   this._curNode,
        token:    this._token
      };

      // If there is no tree, this is the root node.
      if (this._tree === null) {
        this._tree = this._curNode = node;
        return;
      }

      // This node is a child of the current node.
      this._curNode.children.push(node);

      // If the current token is a non-terminal then make the new node the
      // current node.  The tree is structued with non-terminals having terminal
      // children.
      //        __$eq__
      //       /       \
      //    'name'   ':name'
      if (!this._token.terminal)
        this._curNode = node;
    }
  }

  return ConditionParser;
}

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BooleanConverter.html">BooleanConverter</a></li><li><a href="Column.html">Column</a></li><li><a href="ConditionCompiler.html">ConditionCompiler</a></li><li><a href="ConditionError.html">ConditionError</a></li><li><a href="ConditionLexer.html">ConditionLexer</a></li><li><a href="ConditionParser.html">ConditionParser</a></li><li><a href="Database.html">Database</a></li><li><a href="DataContext.html">DataContext</a></li><li><a href="DataMapper.html">DataMapper</a></li><li><a href="Delete.html">Delete</a></li><li><a href="DeleteModel.html">DeleteModel</a></li><li><a href="Escaper.html">Escaper</a></li><li><a href="ForeignKey.html">ForeignKey</a></li><li><a href="From.html">From</a></li><li><a href="FromAdapter.html">FromAdapter</a></li><li><a href="Insert.html">Insert</a></li><li><a href="ModelTraverse.html">ModelTraverse</a></li><li><a href="MutateModel.html">MutateModel</a></li><li><a href="ParameterList.html">ParameterList</a></li><li><a href="Query.html">Query</a></li><li><a href="QueryExecuter.html">QueryExecuter</a></li><li><a href="RelationshipStore.html">RelationshipStore</a></li><li><a href="Schema.html">Schema</a></li><li><a href="Select.html">Select</a></li><li><a href="Table.html">Table</a></li><li><a href="TableMetaList.html">TableMetaList</a></li><li><a href="Update.html">Update</a></li><li><a href="UpdateModel.html">UpdateModel</a></li><li><a href="UTCConverter.html">UTCConverter</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-000 - Example Database Setup.html">000 - Example Database Setup</a></li><li><a href="tutorial-001 - Installing and Connecting.html">001 - Installing and Connecting</a></li><li><a href="tutorial-002 - Select - Select all from a Single Table.html">002 - Select - Select all from a Single Table</a></li><li><a href="tutorial-003 - Select - Limiting Columns.html">003 - Select - Limiting Columns</a></li><li><a href="tutorial-004 - Select - Ad-Hoc Mapping.html">004 - Select - Ad-Hoc Mapping</a></li><li><a href="tutorial-005 - Select - Ordering.html">005 - Select - Ordering</a></li><li><a href="tutorial-006 - Select - Ad-Hoc Converters.html">006 - Select - Ad-Hoc Converters</a></li><li><a href="tutorial-007 - Select - Conditions.html">007 - Select - Conditions</a></li><li><a href="tutorial-008 - Select - Conditions.html">008 - Select - Conditions</a></li><li><a href="tutorial-009 - Select - Joins.html">009 - Select - Joins</a></li><li><a href="tutorial-010 - Insert - Create a Single Model.html">010 - Insert - Create a Single Model</a></li><li><a href="tutorial-011 - Insert - Create Multiple Models.html">011 - Insert - Create Multiple Models</a></li><li><a href="tutorial-012 - Delete - Delete a Single Model.html">012 - Delete - Delete a Single Model</a></li><li><a href="tutorial-013 - Delete - Delete Multiple Models.html">013 - Delete - Delete Multiple Models</a></li><li><a href="tutorial-014 - Delete - Delete Using a From Instance.html">014 - Delete - Delete Using a From Instance</a></li><li><a href="tutorial-015 - Update - Update a Single Model.html">015 - Update - Update a Single Model</a></li><li><a href="tutorial-016 - Update - Update Multiple Models.html">016 - Update - Update Multiple Models</a></li><li><a href="tutorial-017 - Update - Updating Using a From Instance.html">017 - Update - Updating Using a From Instance</a></li><li><a href="tutorial-018 - Schema - Schema Generation Overview.html">018 - Schema - Schema Generation Overview</a></li><li><a href="tutorial-019 - Schema - Customizing Names .html">019 - Schema - Customizing Names (Mapping)</a></li><li><a href="tutorial-020 - Schema - Converters.html">020 - Schema - Converters</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Mon Jul 24 2017 16:36:36 GMT-0700 (PDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
