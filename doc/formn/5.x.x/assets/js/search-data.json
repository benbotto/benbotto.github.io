{
  "0": {
    "id": "0",
    "title": "",
    "content": "  404  Page not found :(  The requested page could not be found.",
    "url": "/doc/formn/5.x.x/404.html",
    "relUrl": "/404.html"
  },
  "1": {
    "id": "1",
    "title": "Basic Model Decorators",
    "content": "Basic Model DecoratorsGenerally, model classes are generated using the Formn CLI.  We’ll cover thatin the Generating Models section.  For now, we’lldefine a model class manually and describe how to make the class Formn capable.A Formn model is just a TypeScript class decorated with theTable decorator.  Within a modelclass, properties that correspond to database columns are decorated with theColumn decorator.  Properties canalso be relational and define relationships with other models, which is coveredin the next section.TableBack in the Getting Started section we defined apeopletable.Let’s make a Formn model for that table.import { Table } from 'formn';@Table({name: 'people'})export class Person {}It’s just a plain TypeScipt class, and theTable decorator makes it availablefor Formn to use.  Note that we’ve opted to give the class the singular namePerson, whereas the underlying database table’s name is people.  As such,we need to pass the name option to theTable decorator.  There are otherTableMetaOptions, likeschema for databases that support schemas.ColumnEach column in a table can have an associated property in a model class.  Thoseproperties are Column decorated.Like Table, theColumn decorator can be suppliedvariousColumnMetaOptions, likethe column name, whether or not the column is nullable, and so on and so forth.Let’s fill out the Person model with someColumn-decorated properties, andthen go over the nitty-gritty.import { Table, Column } from 'formn';@Table({name: 'people'})export class Person {  @Column({name: 'personID', isPrimary: true, isGenerated: true,    isNullable: false, sqlDataType: 'int'})  id: number;  @Column({maxLength: 255, sqlDataType: 'varchar'})  firstName: string;  @Column({maxLength: 255, sqlDataType: 'varchar'})  lastName: string;  @Column({hasDefault: true, isNullable: false, sqlDataType: 'timestamp'})  createdOn: Date;}Aliasing Column NamesDatabase column names and Formn model property names can differ.  Just like wealiased the people table as Person, in the above class thepeople.personID column has been aliased as id.  Behind the scenes, Formnwill map Person.id to/from people.personID.Primary KeysEvery Formn model must have a primary key defined.  A primary key is made upof one or more Column-decoratedproperties.  In the people table, the primary key is defined on thepersonID column.  As such, the corresponding id property has theisPrimary option set in itsColumn decoration.  The personIDcolumn is also auto-incrementing (it’s generated); hence, the isGeneratedoption is enabled.Max LengthWhen we defined the peopletable,we defined a maximum character length for the firstName and lastNamecolumns.  That restriction is echoed above with the maxLength option, whichis useful for validation purposes.Default ValuesDatabase side, people.createdOn is defined with a default ofCURRENT_TIMESTAMP, and it’s not nullable.  For validationpurposes, we supply the hasDefault and isNullable options to createdOn’sColumn decorator.",
    "url": "/doc/formn/5.x.x/doc/models/basic-model-decorators.html",
    "relUrl": "/doc/models/basic-model-decorators.html"
  },
  "2": {
    "id": "2",
    "title": "Basic Retrieval",
    "content": "Basic RetrievalBack in the DataContext section, theDataContext.from methodwas mentioned briefly.  This method is the starting point for retrievingrecords, and it takes a single parameter: AnEntityType, which is someTable-decorated class.  (See theModels section.)DataContext.from returnsa FromAdapter instance whichhas a number of useful operations that we’ll step through in the followingsections.Retrieve All From a Single TableLet’s say you want to select allPersonrecords from the people table that we defined in the GettingStarted section.  To do so,you would call theFromAdapter.selectmethod like so.const query: Select&amp;lt;Person&amp;gt; = dataContext  .from(Person)  .select();You get back a Select instance.  Aswas mentioned in the create example, allFormn queries extend the Query classand thus share a common interface.  We can view the SQL associated with theQuery instance using thetoString method.console.log(query.toString());And we can execute the queryto retrieve thePersonrecords.const people: Person[] = await query  .execute();Full ExampleA complete example follows.  It’s available in the formn-example repository undersrc/retrieve/retrieve-all-people.ts.import { inspect } from 'util';import { MySQLDataContext, ConnectionOptions, Select } from 'formn';import { Person } from '../entity/person.entity';async function main() {  const connOpts: ConnectionOptions = require('../../connections.json');  const dataContext = new MySQLDataContext();  try {    await dataContext.connect(connOpts);    // Create a Select query, which will pull all People records from the    // people table.    const query: Select&amp;lt;Person&amp;gt; = dataContext      .from(Person)      .select();    // Log the generated SQL.    console.log(query.toString());    // Execute the query to get all Person records.    const people: Person[] = await query      .execute();    console.log(inspect(people, {depth: null, compact: false}));    await dataContext.end();  }  catch(err) {    console.error(err);  }}main();Run it using ts-node.npx ts-node ./src/retrieve/retrieve-all-people.tsThe output will look similar to the following.SELECT  `people`.`createdOn` AS `people.createdOn`,        `people`.`firstName` AS `people.firstName`,        `people`.`lastName` AS `people.lastName`,        `people`.`personID` AS `people.id`FROM    `people` AS `people`[  Person {    id: 1,    createdOn: 2019-01-29T02:57:06.000Z,    firstName: 'Joe',    lastName: 'Shmo'  },  Person {    id: 2,    createdOn: 2019-01-29T02:57:06.000Z,    firstName: 'Rand',    lastName: 'AlThore'  },  Person {    id: 3,    createdOn: 2019-01-29T02:57:06.000Z,    firstName: 'Holly',    lastName: 'Davis'  },  Person {    id: 4,    createdOn: 2019-01-29T02:57:06.000Z,    firstName: 'Jenny',    lastName: 'Mather'  },  Person {    id: 5,    createdOn: 2019-01-29T03:05:14.000Z,    firstName: 'Mickey',    lastName: 'Mouse'  },  Person {    id: 6,    createdOn: 2019-01-29T03:06:01.000Z,    firstName: 'Abe',    lastName: 'Lincoln'  }]",
    "url": "/doc/formn/5.x.x/doc/retrieving/basic-retrieval.html",
    "relUrl": "/doc/retrieving/basic-retrieval.html"
  },
  "3": {
    "id": "3",
    "title": "Batch Deleting",
    "content": "Batch DeletingPreviously we covered deleting a single model by id.We can also perform more complex, batch deletes using a where clause andoptionally joining tables.Batch deleting is nearly identical to BatchUpdating, so you should be familiar with thatsection.  Like a batch update, a batch delete starts out with a call toDataContext.from.  Thatreturns a FromAdapter instance,which can be used to add a where clause, and/or join in additional tables.  FromAdapter.where:Add a where clause to the query.  FromAdapter.innerJoin:Inner join a table.  FromAdapter.leftOuterJoin:Left outer join a table.The FromAdapter class also hasa delete method.  Itreturns a Delete instance that’sused to batch delete records.Next up, we’ll go through some example code that deletes using a where clauseand a join.Batch Delete a Person’s Phone NumbersIn the example database, wedefined people and phone_numbers tables, along with modelsfor each.  Now let’s say we want to delete all thePhoneNumberrecords associated with aPerson,and we want to identify the person by firstName and lastName.  We’lldelete from the phone_numbers table, join in people, and set anappropriate where clause.  If you’re not familiar with where conditions orjoining, take a look at those sections:Joining;Conditions.// Used for building the delete's where clause.const cb = new ConditionBuilder();// Delete all PhoneNumber (pn) records for the Person (p) named// &quot;Rand Althore.&quot;const query: Delete = dataContext  .from(PhoneNumber, 'pn')  .innerJoin(Person, 'p', 'pn.person')  .where(    cb.and(      cb.eq('p.firstName', ':fname', 'Rand'),      cb.eq('p.lastName', ':lname', 'AlThore')))  .delete('pn');As mentioned above, a Deleteinstance is returned.  It’s a type ofQuery, so we can view the generatedSQL by calling toString.console.log(query.toString());To run the query, weexecute it.const result: MutateResultType = await query.execute();The result will have at least an affectedRows property, indicating thenumber of deleted rows.Full ExampleThe full code presented above can be found in the formn-example repositoryundersrc/delete/delete-phone-numbers-for-person.ts.import { inspect } from 'util';import {  MySQLDataContext, ConnectionOptions, ConditionBuilder, Delete,  MutateResultType} from 'formn';import { PhoneNumber } from '../entity/phone-number.entity';import { Person } from '../entity/person.entity';async function main() {  const connOpts: ConnectionOptions = require('../../connections.json');  const dataContext = new MySQLDataContext();  try {    await dataContext.connect(connOpts);    // Used for building the delete's where clause.    const cb = new ConditionBuilder();    // Delete all PhoneNumber (pn) records for the Person (p) named    // &quot;Rand Althore.&quot;    const query: Delete = dataContext      .from(PhoneNumber, 'pn')      .innerJoin(Person, 'p', 'pn.person')      .where(        cb.and(          cb.eq('p.firstName', ':fname', 'Rand'),          cb.eq('p.lastName', ':lname', 'AlThore')))      .delete('pn');    console.log(query.toString());    // The result will have at least an affectedRows property.    const result: MutateResultType = await query.execute();    console.log(inspect(result, {depth: null, compact: false}));    await dataContext.end();  }  catch(err) {    console.error(err);  }}main();Run the example with ts-node.npx ts-node ./src/delete/delete-phone-numbers-for-person.tsOutput will look like this.DELETE  `pn`FROM    `phone_numbers` AS `pn`INNER JOIN `people` AS `p` ON `pn`.`personID` = `p`.`personID`WHERE   (`p`.`firstName` = :fname AND `p`.`lastName` = :lname)ResultSetHeader {  fieldCount: 0,  affectedRows: 1,  insertId: 0,  info: '',  serverStatus: 34,  warningStatus: 0}",
    "url": "/doc/formn/5.x.x/doc/deleting/batch-deleting.html",
    "relUrl": "/doc/deleting/batch-deleting.html"
  },
  "4": {
    "id": "4",
    "title": "Batch Updating",
    "content": "Batch UpdatingIn the previous section we updated a single model byid.  While that’s a common scenario, often there’s a need to update a bunch ofrecords simultaneously based on some filter condition.If you look back at the DataContext section, you’ll see thatthe DataContext.frommethod can be used for batch updating.  As was mentioned in the BasicRetrieval section, theDataContext.from methodreturns a FromAdapterinstance.  That class has anupdate method that canbe used to perform batch updates.Update With a Where ClauseIn the last chapter, Conditions were covered.Because both retrieving and batch updating share a common inteface–namelyFromAdapter–both are filteredin the same way: using theFromAdapter.where methodalong with theConditionBuilder class.(You can also use join operations, as described inJoining and BatchDeleting.)When we created the exampledatabase, we added typecolumn to the phone_numbers table.  Let’s change all “mobile” phone numbersto “cell.”// Used for building the update statement's where clause.const cb = new ConditionBuilder();// Change phone_numbers.type from &quot;mobile&quot; to &quot;cell.&quot;const query: Update = dataContext  .from(PhoneNumber, 'pn')  .where(cb.eq('pn.type', ':mob', 'mobile'))  .update({'pn.type': 'cell'});In the above code, we’ve used theDataContext.from method,supplying two parameters:  An EntityType, which is someTable-decorated class.  (See theModels section.)  An alias, which lets us reference theEntityType using ashort-hand notation (pn above).We then used theFromAdapter.where methodto filter the query, limiting the update to mobile-type phone numbers.(Building conditions and filtering queries is covered in greater depth in theConditions section.)  Lastly, we calledFromAdapter.update,supplying a single object as a parameter.  Each key in the object correspondsto a fully-qualified property name in the form &amp;lt;table-alias&amp;gt;.&amp;lt;property-name&amp;gt;.Above, we set pn.type to “cell.”FromAdapter.updatereturns an Update instance.  Andlike all Formn queries, that class inherits fromQuery.  As usual, we can log the SQLfor debugging purposes usingUpdate.toString.console.log(query.toString());And to run the query, we callUpdate.execute.const result: MutateResultType = await query.execute();The returnedMutateResultType willhave at least an affectedRows property describing how many rows were updated.Full ExampleThe example presented above is located undersrc/update/batch-update-mobile-numbers.tsin the formn-example repository.  Run it with ts-node.npx ts-node ./src/update/batch-update-mobile-numbers.tsThe output is shown below.UPDATE  `phone_numbers` AS `pn`SET`pn`.`type` = :pn_type_0WHERE   `pn`.`type` = :mobResultSetHeader {  fieldCount: 0,  affectedRows: 2,  insertId: 0,  info: 'Rows matched: 2  Changed: 2  Warnings: 0',  serverStatus: 34,  warningStatus: 0,  changedRows: 2}Note that only the affectedRows property is guaranteed, but additionalmetadata may be present depending on the underlying database driver.",
    "url": "/doc/formn/5.x.x/doc/updating/batch-updating.html",
    "relUrl": "/doc/updating/batch-updating.html"
  },
  "5": {
    "id": "5",
    "title": "Conditions",
    "content": "ConditionsThe easiest way to create conditions with Formn is to use theConditionBuilder class.You build a condition, and then pass it to theFromAdapter.where methodto filter a query.Basic ComparisonsThe ConditionBuilder classprovides these basic comparison functions.  eq: Equal (=)comparison.  neq: Not equal(&amp;lt;&amp;gt;) comparison.  lt: Less than (&amp;lt;)comparison.  lte: Less than orequal to (&amp;lt;=) comparison.  gt: Greater than(&amp;gt;) comparison.  gte: Greater thanor equal to (&amp;gt;=) comparison.  like: Like(LIKE) comparison.  notLike: Notlike (NOT LIKE) comparison.  in: In (IN (...))comparison.  notIn: Not in(NOT IN (...)) comparison.  isNull: Is null(IS NULL) comparison.  isNotNull: Isnot null (IS NOT NULL) comparison.In a nutshell, you build a condition, then pass the result to theFromAdapter.wheremethod.  For example, if we wanted to find allPersonrecords with a firstName of “Joe,” we would use theeq method.const query: Select&amp;lt;Person&amp;gt; = dataContext  .from(Person, 'p')  .where(    cb.eq('p.firstName', ':myFirstName', 'Joe'))  .select();// Resulting condition: WHERE   `p`.`firstName` = :myFirstNameOr, if we wanted to find all people created after New Years, 2019.const query: Select&amp;lt;Person&amp;gt; = dataContext  .from(Person, 'p')  .where(    cb.gt('p.createdOn', ':newyears', new Date('2019-01-01')))  .select();// Resulting condition: WHERE   `p`.`createdOn` &amp;gt; :newyearsLogical (Aggregate) ConditionsConditions can be combined using theand andor methods.  Let’s saywe want to find allPersonrecords that have a “j” in the first or last name.const query: Select&amp;lt;Person&amp;gt; = dataContext  .from(Person, 'p')  .where(    cb.or(      cb.like('p.firstName', ':letter', '%j%'),      cb.like('p.lastName', ':letter', '%j%')))  .select();// Resulting condition: WHERE   (`p`.`firstName` LIKE :letter OR `p`.`lastName` LIKE :letter)Above, two basic LIKE comparisons are OR‘d together.  Now let’s find peoplewith a “j” and an “r” in the first or last name (e.g. “Jenny Mather”).const query: Select&amp;lt;Person&amp;gt; = dataContext  .from(Person, 'p')  .where(    cb.and(      cb.or(        cb.like('p.firstName', ':letter1', '%j%'),        cb.like('p.lastName', ':letter1', '%j%')),      cb.or(        cb.like('p.firstName', ':letter2', '%r%'),        cb.like('p.lastName', ':letter2', '%r%'))))  .select();// Resulting condition:// WHERE   ((`p`.`firstName` LIKE :letter1 OR `p`.`lastName` LIKE :letter1) AND//          (`p`.`firstName` LIKE :letter2 OR `p`.`lastName` LIKE :letter2))Obviously, Formn places parentheses around logically-grouped conditions sothat the operator precedence is correct.Conditions from Objects (Advanced)The FromAdapter.wheremethod is overloaded.  Rather than using theConditionBuilder class,you can pass two parameters:  A condition object.  A parameter object that contains key-value pairs.  Each key corresponds to aparameter in the condition object.The ConditionBuilderclass just builds condition objects using a simple interface.  After building acondition, you can see the resulting condition object using theParameterizedCondition.getCondmethod.const pCond = cb.and(  cb.or(    cb.like('p.firstName', ':letter1', '%j%'),    cb.like('p.lastName', ':letter1', '%j%')),  cb.or(    cb.like('p.firstName', ':letter2', '%r%'),    cb.like('p.lastName', ':letter2', '%r%')));console.log(inspect(pCond.getCond(), {depth: null, compact: false}));/*{  '$and': [    {      '$or': [        {          '$like': {            'p.firstName': ':letter1'          }        },        {          '$like': {            'p.lastName': ':letter1'          }        }      ]    },    {      '$or': [        {          '$like': {            'p.firstName': ':letter2'          }        },        {          '$like': {            'p.lastName': ':letter2'          }        }      ]    }  ]}*/The objects are in prefix notation, similar to MongoDB’s conditions, and theyfollow a formal language specification.  That spec can be foundhere.Using condition objects, one could, for example, accept dynamic conditions viaan API, or build complex conditions on the fly.Full ExampleYou can see the above example in the formn-example repository undersrc/retrieve/conditions.ts.import { inspect } from 'util';import { MySQLDataContext, ConnectionOptions, Select, ConditionBuilder } from 'formn';import { Person } from '../entity/person.entity';async function main() {  const connOpts: ConnectionOptions = require('../../connections.json');  const dataContext = new MySQLDataContext();  try {    await dataContext.connect(connOpts);    // The ConditionBuilder class is used to build WHERE or ON conditions.    const cb = new ConditionBuilder();    // People with a &quot;j&quot; and an &quot;r&quot; in their name, like Jenny Mather.    const query: Select&amp;lt;Person&amp;gt; = dataContext      .from(Person, 'p')      .where(        cb.and(          cb.or(            cb.like('p.firstName', ':letter1', '%j%'),            cb.like('p.lastName', ':letter1', '%j%')),          cb.or(            cb.like('p.firstName', ':letter2', '%r%'),            cb.like('p.lastName', ':letter2', '%r%'))))      .select();    console.log(query.toString());    const people: Person[] = await query      .execute();    console.log(inspect(people, {depth: null, compact: false}));    await dataContext.end();  }  catch(err) {    console.error(err);  }}main();It can be run with ts-node:npx ts-node ./src/retrieve/conditions.tsThe output will look something like this:SELECT  `p`.`createdOn` AS `p.createdOn`,        `p`.`firstName` AS `p.firstName`,        `p`.`lastName` AS `p.lastName`,        `p`.`personID` AS `p.id`FROM    `people` AS `p`WHERE   ((`p`.`firstName` LIKE :letter1 OR `p`.`lastName` LIKE :letter1) AND (`p`.`firstName` LIKE :letter2 OR `p`.`lastName` LIKE :letter2))[  Person {    id: 4,    createdOn: 2019-01-24T07:14:07.000Z,    firstName: 'Jenny',    lastName: 'Mather'  }]",
    "url": "/doc/formn/5.x.x/doc/retrieving/conditions.html",
    "relUrl": "/doc/retrieving/conditions.html"
  },
  "6": {
    "id": "6",
    "title": "Connecting",
    "content": "ConnectingThis section covers setting up a database connection using Formn.  You may wantto review the DataContext section first.",
    "url": "/doc/formn/5.x.x/doc/connecting/",
    "relUrl": "/doc/connecting/"
  },
  "7": {
    "id": "7",
    "title": "Connection Options",
    "content": "Connection OptionsConnection options include a database, host, port, credentials, and a few othermeta-type options.  Take a look at theConnectionOptionsdocumentation for complete details.  By convention, connection options areusually placed in a connections.json file at the root of your project.Here’s an example connections.json file.{  &quot;host&quot;: &quot;127.0.0.1&quot;,  &quot;user&quot;: &quot;formn-user&quot;,  &quot;password&quot;: &quot;formn-password&quot;,  &quot;database&quot;: &quot;formn_test_db&quot;,  &quot;port&quot;: 3306,  &quot;poolSize&quot;: 10}The above JSON object was taken from the formn-example repository.  Seeconnections.json.",
    "url": "/doc/formn/5.x.x/doc/connecting/connection-options.html",
    "relUrl": "/doc/connecting/connection-options.html"
  },
  "8": {
    "id": "8",
    "title": "Creating",
    "content": "CreatingThis section deals with inserting entities into the database.  It assumesfamiliarity with the Getting Started,DataContext, and Models sections.",
    "url": "/doc/formn/5.x.x/doc/creating/",
    "relUrl": "/doc/creating/"
  },
  "9": {
    "id": "9",
    "title": "Custom Join Predicates",
    "content": "Custom Join PredicatesIn the queries presented in the last section, the joinpredicates (the ON condition) are derived.  That is, Formn infers the joinconditions based on the decorators defined on the models.  But sometimes that’snot enough, and a custom join predicate is needed.  TheConditionBuilder classthat was covered in the conditions section can be used tobuild a custom join condition.Let’s say we want to pull allPersonrecords, along with their mobilePhoneNumbers,if any.// The ConditionBuilder is used to build the join predicate.const cb = new ConditionBuilder();// People with their mobile phone numbers, if any.const query: Select&amp;lt;Person&amp;gt; = dataContext  .from(Person, 'p')  .leftOuterJoin(PhoneNumber, 'pn', 'p.phoneNumbers',    cb.and(      cb.eq('p.id', 'pn.personId'),      cb.eq('pn.type', ':phoneType', 'mobile')))  .select();Full ExampleYou’ll find the above example in the formn-example repository undersrc/retrieve/join-people-to-phone-numbers-custom-condition.ts.import { inspect } from 'util';import { MySQLDataContext, ConnectionOptions, Select, ConditionBuilder } from 'formn';import { Person } from '../entity/person.entity';import { PhoneNumber} from '../entity/phone-number.entity';async function main() {  const connOpts: ConnectionOptions = require('../../connections.json');  const dataContext = new MySQLDataContext();  try {    await dataContext.connect(connOpts);    // The ConditionBuilder is used to build the join predicate.    const cb = new ConditionBuilder();    // People with their mobile phone numbers, if any.    const query: Select&amp;lt;Person&amp;gt; = dataContext      .from(Person, 'p')      .leftOuterJoin(PhoneNumber, 'pn', 'p.phoneNumbers',        cb.and(          cb.eq('p.id', 'pn.personId'),          cb.eq('pn.type', ':phoneType', 'mobile')))      .select();    console.log(query.toString());    const people: Person[] = await query      .execute();    console.log(inspect(people, {depth: null, compact: false}));    await dataContext.end();  }  catch(err) {    console.error(err);  }}main();The example can be run with ts-node.npx ts-node ./src/retrieve/join-people-to-phone-numbers-custom-condition.tsThe above yields the following output.SELECT  `p`.`createdOn` AS `p.createdOn`,        `p`.`firstName` AS `p.firstName`,        `p`.`lastName` AS `p.lastName`,        `p`.`personID` AS `p.id`,        `pn`.`personID` AS `pn.personId`,        `pn`.`phoneNumber` AS `pn.phoneNumber`,        `pn`.`phoneNumberID` AS `pn.id`,        `pn`.`type` AS `pn.type`FROM    `people` AS `p`LEFT OUTER JOIN `phone_numbers` AS `pn` ON (`p`.`personID` = `pn`.`personID` AND `pn`.`type` = :phoneType)[  Person {    id: 1,    createdOn: 2019-02-13T03:37:23.000Z,    firstName: 'Joe',    lastName: 'Shmo',    phoneNumbers: [      PhoneNumber {        id: 1,        personId: 1,        phoneNumber: '530-307-8810',        type: 'mobile'      }    ]  },  Person {    id: 2,    createdOn: 2019-02-13T03:37:23.000Z,    firstName: 'Rand',    lastName: 'AlThore',    phoneNumbers: [      PhoneNumber {        id: 4,        personId: 2,        phoneNumber: '666-451-4412',        type: 'mobile'      }    ]  },  Person {    id: 3,    createdOn: 2019-02-13T03:37:23.000Z,    firstName: 'Holly',    lastName: 'Davis',    phoneNumbers: []  },  Person {    id: 4,    createdOn: 2019-02-13T03:37:23.000Z,    firstName: 'Jenny',    lastName: 'Mather',    phoneNumbers: []  }]Note the custom join predicate:LEFT OUTER JOIN `phone_numbers` AS `pn` ON   (`p`.`personID` = `pn`.`personID` AND `pn`.`type` = :phoneType)",
    "url": "/doc/formn/5.x.x/doc/retrieving/custom-join-predicates.html",
    "relUrl": "/doc/retrieving/custom-join-predicates.html"
  },
  "10": {
    "id": "10",
    "title": "DataContext",
    "content": "DataContextFormn is similar to LINQ to SQL in that most database operations are done via aDataContext instance.  Thereis one DataContextimplementation per supported database flavor.  For example, for a MySQLdatabase you would use aMySQLDataContext.In the coming chapters we’ll cover instantiating and using this class, but fornow note that the followingDataContext methods arecommonly used.  connect: Connect toa database.  insert: Insert amodel into the database.  from: Select fromthe database, or batch update or delete records from the database.  update: Update a model.  delete: Delete a model.  beginTransaction:Start a database transaction.Each will be explored in greater detail in the next sections.",
    "url": "/doc/formn/5.x.x/doc/datacontext/",
    "relUrl": "/doc/datacontext/"
  },
  "11": {
    "id": "11",
    "title": "Deleting a Model",
    "content": "Deleting a ModelA common scenario is to delete a single model by id.  That’s done using theDataContext.deletemethod.  The usage is pretty much identical to updating a model by id, so besure to review the Updating a Modelsection.  It has more detailed documentation.Delete a PhoneNumber InstanceDeleting a record by id is simple.  Below we’ll delete a singlePhoneNumberrecord.// Delete the PhoneNumber with ID 1.const phone = new PhoneNumber();phone.id = 1;const query: DeleteModel&amp;lt;PhoneNumber&amp;gt; = dataContext  .delete(PhoneNumber, phone);console.log(query.toString());// If no rows are affected (i.e. if a phone number with an id of 1 does not// exist), then an error will be raised.await query.execute();First, we instantiate aPhoneNumberand set the id to 1.  Then we callDataContext.delete,supplying two parameters:  An EntityType, which is someTable-decorated class.  (See theModels section.)  A model, which is an instance of theEntityType.  The model musthave at least the primary key set.That returns a DeleteModelinstance, which is a type of Query.Like all Fomrn queries, we can log the SQL that Formn generates usingDeleteModel.toString,and execute it.Note that if there is no record with an id of 1, then an error is raised.Full ExampleThe code discussed above is in the formn-example repository undersrc/delete/delete-phone-number.ts.It’s also printed below for convenience.import {  MySQLDataContext, ConnectionOptions, DeleteModel} from 'formn';import { PhoneNumber } from '../entity/phone-number.entity';async function main() {  const connOpts: ConnectionOptions = require('../../connections.json');  const dataContext = new MySQLDataContext();  try {    await dataContext.connect(connOpts);    // Delete the PhoneNumber with ID 1.    const phone = new PhoneNumber();    phone.id = 1;    const query: DeleteModel&amp;lt;PhoneNumber&amp;gt; = dataContext      .delete(PhoneNumber, phone);    console.log(query.toString());    // If no rows are affected (i.e. if a phone number with an id of 1 does not    // exist), then an error will be raised.    await query.execute();    await dataContext.end();  }  catch(err) {    console.error(err);  }}main();Run it using ts-node.npx ts-node ./src/delete/delete-phone-number.tsHere’s the output:DELETE  `phone_numbers`FROM    `phone_numbers` AS `phone_numbers`WHERE   (`phone_numbers`.`phoneNumberID` = :phone_numbers_id_0)",
    "url": "/doc/formn/5.x.x/doc/deleting/deleting-a-model.html",
    "relUrl": "/doc/deleting/deleting-a-model.html"
  },
  "12": {
    "id": "12",
    "title": "Deleting",
    "content": "DeletingThis chapter goes over deleting records.  Updating and deleting are quitesimilar, so be sure to read the chapter on Updating.  Youshould also be up to speed on the basics, like GettingStarted, DataContext, andModels.",
    "url": "/doc/formn/5.x.x/doc/deleting/",
    "relUrl": "/doc/deleting/"
  },
  "13": {
    "id": "13",
    "title": "Env Vars",
    "content": "Env VarsFormn provides a helper class,ConnectionsFileReader,that can be used to read and validate a connections.json file.  ItsreadConnectionOptionsmethod takes a path to a connections.json file, and returns an array ofConnectionOptions.Because it’s common to use environment variables to store database connectiondetails, a connections.json file can be defined in such a way that some orall of the connection options come from environment variables.  Here’s anexample connections.json file that’s set up to get the database host andpassword from env vars.{  &quot;host&quot;: {    &quot;ENV&quot;: &quot;DB_HOST&quot;  },  &quot;user&quot;: &quot;formn-user&quot;,  &quot;password&quot;: {    &quot;ENV&quot;: &quot;DB_PASS&quot;  },  &quot;database&quot;: &quot;formn_test_db&quot;,  &quot;port&quot;: 3306,  &quot;poolSize&quot;: 10}Here, the host is expected to be in the DB_HOST environment variable, and thepassword in DB_PASS.  Once that file is defined, it can be read as follows.import { ConnectionsFileReader, ConnectionOptions } from 'formn';// Read connection details.  DB_HOST and DB_PASS should be defined// as env vars, otherwise an exception will be raised.const connOpts: ConnectionOptions = new ConnectionsFileReader()  .readConnectionOptions('connections.env.json')[0];There are a few key differences from the last example.  readConnectionOptionstakes the path to a connections.json file.  If the path is relative, it’sassumed to be relative to the current working directory, which is likely theroot of your application.  In the last examplethe connections.json file was simply read using require.  readConnectionOptionsreturns an array ofConnectionOptions.  Someapplications need to connect to multiple databases, so a connections.jsonfile can define an array of connection details.The two files referenced above can be found in the formn-example repository:connections.env.json;read-connections-env.ts.",
    "url": "/doc/formn/5.x.x/doc/connecting/env-vars.html",
    "relUrl": "/doc/connecting/env-vars.html"
  },
  "14": {
    "id": "14",
    "title": "Establishing a Connection",
    "content": "Establishing a ConnectionAs discussed in the DataContext section, eachDataContext implementationexposes a connectmethod.  It takes a singleConnectionOptionsparameter.  Assuming you’ve followed the tutorial and defined your connectionoptions in a root-level connections.json object (see the ConnectionOptions section), code for establishing aconnection will look as follows.import { MySQLDataContext, ConnectionOptions } from 'formn';async function main() {  // Load ConnectionOptions from a JSON file.  const connOpts: ConnectionOptions = require('../../connections.json');  // Initialize a DataContext instance for MySQL.  const dataContext = new MySQLDataContext();  // Attempt to connect.  Log an error on failure, and end the connection on  // completion.  try {    await dataContext.connect(connOpts);    console.log('Connected!');  }  catch(err) {    console.error('Failed to connect.');    console.error(err);  }  finally {    await dataContext.end();  }}main();The above example can be found in the formn-example repository undersrc/connection/connect.ts.Run it with ts-node:npx ts-node ./src/connection/connect.ts",
    "url": "/doc/formn/5.x.x/doc/connecting/establishing-a-connection.html",
    "relUrl": "/doc/connecting/establishing-a-connection.html"
  },
  "15": {
    "id": "15",
    "title": "Generating Models",
    "content": "Generating ModelsManually defining models is cumbersome, so Formn’s CLI provides a helper toolto generate models from an existing database schema.PrerequisitesIf you haven’t alreadydone so, install the formn-cli package globally.npm install -g formn-cliYou’ll also need to define a connections.json file as described in theConnecting section.  Formn generates models using databasemetadata defined in the INFORMATION_SCHEMA tables, so the credentialssupplied in the connections.json file must have sufficient permission.Generating ModelsThe Formn CLI command for generating models is generate, aliased g.  Youcan see all the commands and options using the --help switch.formn --helpformn generate --helpOptions include:  --connections-file, aliased as -c.  The path to a connections.jsonfile, which defaults to ./connections.json  --flavor, aliased -f.  The database type, which defaults to mysql.The generate command requires one argument: the path where model classesshould be written.  Here’s an example.formn g src/entity/Assuming you’ve been following along with the tutorial, running the abovecommand will generate two model classes:person.entity.tsandphone-number.entity.ts.Customizing Generated ModelsYou may have noticed that the class and property names in the generated modelsdo not correspond directly to the database table and column names.  Forexample, the class names are singular and pascal case (Person andPhoneNumber), whereas the database tables names are plural and snake case(people and phone_numbers).  Also, the properties associated with primarykeys have been aliased as Person.id and PhoneNumber.id.  If that namingconvention is okay with you, then feel free to skip this section, but do notethat the formatting can be customized to your liking.The code responsible for model generation in Formn is theModelGenerator class.(There’s one implementation per database flavor, for exampleMySQLModelGenerator).The ModelGeneratorconstructortakes three parameters that are used for formatting class names,column-decorated property names, and relationship-decorated property names.Those parameters are instances ofTableFormatter,ColumnFormatter, andRelationshipFormatter,respectively.  The Formn CLI uses the defaults:DefaultTableFormatter,DefaultColumnFormatter,andDefaultRelationshipFormatter.If you want to customize the generated models, then you’ll need to implementone or more of the above interfaces, and then instantiate aModelGenerator manually.Take a look at the formn-cli code for an example:cli-model-generator.ts.",
    "url": "/doc/formn/5.x.x/doc/models/generating-models.html",
    "relUrl": "/doc/models/generating-models.html"
  },
  "16": {
    "id": "16",
    "title": "Getting Started",
    "content": "Getting StartedThis section covers setting up a project with a TypeScript configuration andinstalling required dependencies.",
    "url": "/doc/formn/5.x.x/doc/getting-started/",
    "relUrl": "/doc/getting-started/"
  },
  "17": {
    "id": "17",
    "title": "Home",
    "content": "FormnFormn, pronounced foreman, is an object-relational mapper for Node.js. What’sthe “F” stand for? It depends on your mood.It’s a fast, database-first ORM for projects written in TypeScript, and it usesthe data-mapper pattern.What does it do?It takes queries that look like this:SELECT  p.personID, p.firstName, p.lastName,        pn.phoneNumberID, pn.phoneNumberFROM    people pINNER JOIN phone_numbers pn ON p.personID = pn.personIDORDER BY p.firstName, p.lastNameand makes them look like this:const query: Select&amp;lt;Person&amp;gt; = dataContext  .from(Person, 'p')  .innerJoin(PhoneNumber, 'pn', 'p.phoneNumbers')  .select(    'p.id', 'p.firstName', 'p.lastName',    'pn.id', 'pn.phoneNumber')  .orderBy('p.firstName', 'p.lastName')const people: Person[] = await query  .execute();It maps tabular, relational data that look like this:            personID      firstName      lastName      phoneNumberID      phoneNumber                  1      Joe      Shmo      1      530-307-8810              1      Joe      Shmo      2      916-200-1440              1      Joe      Shmo      3      916-293-4667              2      Rand      AlThore      4      666-451-4412      to normalized entities that look like this:[  Person {    id: 1,    firstName: 'Joe',    lastName: 'Shmo',    phoneNumbers: [      PhoneNumber {        id: 1,        phoneNumber: '530-307-8810'      },      PhoneNumber {        id: 2,        phoneNumber: '916-200-1440'      },      PhoneNumber {        id: 3,        phoneNumber: '916-293-4667'      }    ]  },  Person {    id: 2,    firstName: 'Rand',    lastName: 'AlThore',    phoneNumbers: [      PhoneNumber {        id: 4,        phoneNumber: '666-451-4412'      }    ]  }]Why should I use it?  It’s fast.  The code is well documented and thoroughly tested.  Tutorials and documentation help you to get started quickly.  It’s database first rather than entity first, so it works well with existingprojects and databases.  There’s a built-in model generator to generate entity classes from adatabase.  The query interface is intuitive and closely resembles SQL.  It’s type safe.  Security concerns like SQL injection are covered.  CRUD operations can be reused.  One complex query with joins and filters canbe used to select, update, and delete in a similar manner to SQL views.  It lets you easily create queries that can be filtered and ordereddynamically.  There are hooks for global conversions and transformations, like normalizingdates and formatting phone numbers.",
    "url": "/doc/formn/5.x.x/",
    "relUrl": "/"
  },
  "18": {
    "id": "18",
    "title": "Insert a Record",
    "content": "Insert a RecordLike connecting, query operations in Formn originate with aDataContext instance.  (Seethe DataContext section.) TheDataContext.insertmethod is used to insert a model instance into the database.Insert a Person InstanceBack in the Getting Started section we set up anexample database.  Then, inthe Models section, we defined aPersonentity class.  Let’s walk through the process of inserting aPerson.First, instantiate and populate aPerson(president below).const president = new Person();president.firstName = 'Abe';president.lastName  = 'Lincoln';Next, create an Insert instanceusing theDataContext.insertmethod.  It takes two parameters.  An EntityType, which is aTable-decorated class.  (See theModels section.)  We’re inserting aPerson.  An instance of that EntityType (president).const query: Insert&amp;lt;Person&amp;gt; = dataContext.insert(Person, president);Insert is a type ofQuery, and, like all Formn queries,you can call the toStringmethod to see the underlying SQL associated with theQuery instance.  This method isuseful for logging and debugging purposes.console.log(query.toString());Finally, execute the queryto insert the president record.await query.execute();SincePerson’sprimary key is generated (an auto-incrementing int), Formn sets the generatedid on the president instance.Full ExampleHere’s the full example, which can be found in the formn-example repositoryundersrc/create/create-person.ts.import { inspect } from 'util';import { MySQLDataContext, ConnectionOptions, Insert } from 'formn';import { Person } from '../entity/person.entity';async function main() {  const connOpts: ConnectionOptions = require('../../connections.json');  const dataContext = new MySQLDataContext();  try {    await dataContext.connect(connOpts);    // Create a new Person instance.    const president = new Person();    president.firstName = 'Abe';    president.lastName  = 'Lincoln';    // Create an Insert query.    const query: Insert&amp;lt;Person&amp;gt; = dataContext.insert(Person, president);    // This is the SQL that will be executed on Query.execute();    console.log(query.toString());    // Persist the person.    await query.execute();    // The new person has the generated ID set.    console.log(inspect(president, {depth: null, compact: false}));  }  catch(err) {    console.error('Error creating user.');    console.error(err);  }  finally {    await dataContext.end();  }}main();Run the example with ts-node:npx ts-node ./src/create/create-person.tsThe output will look similar to this.INSERT INTO `people` (`firstName`, `lastName`)VALUES (:firstName, :lastName)Person {  firstName: 'Abe',  lastName: 'Lincoln',  id: 5}",
    "url": "/doc/formn/5.x.x/doc/creating/insert-a-record.html",
    "relUrl": "/doc/creating/insert-a-record.html"
  },
  "19": {
    "id": "19",
    "title": "Installing",
    "content": "InstallingAt a minimum, your project will need formn and a supported database driverinstalled.Install Formnnpm install --save formnInstall a Database Driver  MySQL    npm install --save mysql2 types/mysql2       Optional DependenciesFormn is database first, meaning that you create your database schema first,and then define entity model classes in TypeScript.  The Formn command-lineinterface (CLI) has a model generator that can be used to generate entityclasses for you.  You can install the CLI locally or globally (the tutorialsassume the latter).npm install -g formn-cliThroughout these tutorials ts-node isused to execute the example TypeScript scripts, so you may want to installthat.npm install --save-dev ts-nodeLastly, the tutorials use some of the built-in Node.js utilities, so you mightwant to install @types/node.npm install --save @types/node",
    "url": "/doc/formn/5.x.x/doc/getting-started/installing.html",
    "relUrl": "/doc/getting-started/installing.html"
  },
  "20": {
    "id": "20",
    "title": "Joining",
    "content": "JoiningGenerally, joining two tables is straight forward.  How two models are relatedis defined on the models using relationship decorators,OneToMany,OneToOne, orManyToOne.  Formn uses thatmetadata to join the tables together.For example, back when we defined ourmodels, we specified a one-to-manyrelationship betweenPersonandPhoneNumber,and a many-to-one relationship in the opposite direction.  With thoserelationships in place, we can pull all thePersonrecords along with eachPerson’sPhoneNumbers.We do that with one of theFromAdapter’s join methods:leftOuterJoin orinnerJoin.  Here’s an example:const query: Select&amp;lt;Person&amp;gt; = dataContext  .from(Person, 'p')  .leftOuterJoin(PhoneNumber, 'pn', 'p.phoneNumbers')  .select();That says to join from people to phone_numbers, using the relationshipdefined on the p.phoneNumbers property.  You’ll get back allPersonrecords, and eachPersonwill have an array ofPhoneNumbers.If you wanted to go the other direction, joining from phone_numbers topeople:const query: Select&amp;lt;PhoneNumber&amp;gt; = dataContext  .from(PhoneNumber, 'pn')  .innerJoin(Person, 'p', 'pn.person')  .select();which would give you allPhoneNumbers,each with aPersoninstance.Full ExampleBoth examples presented above are available in the formn-example repository.  Take a look atsrc/retrieve/join-people-to-phone-numbers.tsandsrc/retrieve/join-phone-numbers-to-people.ts.The former is presented below.import { inspect } from 'util';import { MySQLDataContext, ConnectionOptions, Select } from 'formn';import { Person } from '../entity/person.entity';import { PhoneNumber} from '../entity/phone-number.entity';async function main() {  const connOpts: ConnectionOptions = require('../../connections.json');  const dataContext = new MySQLDataContext();  try {    await dataContext.connect(connOpts);    // People with their phone numbers.    const query: Select&amp;lt;Person&amp;gt; = dataContext      .from(Person, 'p')      .leftOuterJoin(PhoneNumber, 'pn', 'p.phoneNumbers')      .select();    console.log(query.toString());    const people: Person[] = await query      .execute();    console.log(inspect(people, {depth: null, compact: false}));    await dataContext.end();  }  catch(err) {    console.error(err);  }}main();As usual, run it with ts-node.npx ts-node ./src/retrieve/join-people-to-phone-numbers.tsThe output will look similar to the following.SELECT  `p`.`createdOn` AS `p.createdOn`,        `p`.`firstName` AS `p.firstName`,        `p`.`lastName` AS `p.lastName`,        `p`.`personID` AS `p.id`,        `pn`.`personID` AS `pn.personId`,        `pn`.`phoneNumber` AS `pn.phoneNumber`,        `pn`.`phoneNumberID` AS `pn.id`,        `pn`.`type` AS `pn.type`FROM    `people` AS `p`LEFT OUTER JOIN `phone_numbers` AS `pn` ON `p`.`personID` = `pn`.`personID`[  Person {    id: 1,    createdOn: 2019-02-13T03:37:23.000Z,    firstName: 'Joe',    lastName: 'Shmo',    phoneNumbers: [      PhoneNumber {        id: 1,        personId: 1,        phoneNumber: '530-307-8810',        type: 'mobile'      },      PhoneNumber {        id: 2,        personId: 1,        phoneNumber: '916-200-1440',        type: 'home'      },      PhoneNumber {        id: 3,        personId: 1,        phoneNumber: '916-293-4667',        type: 'office'      }    ]  },  Person {    id: 2,    createdOn: 2019-02-13T03:37:23.000Z,    firstName: 'Rand',    lastName: 'AlThore',    phoneNumbers: [      PhoneNumber {        id: 4,        personId: 2,        phoneNumber: '666-451-4412',        type: 'mobile'      }    ]  },  Person {    id: 3,    createdOn: 2019-02-13T03:37:23.000Z,    firstName: 'Holly',    lastName: 'Davis',    phoneNumbers: []  },  Person {    id: 4,    createdOn: 2019-02-13T03:37:23.000Z,    firstName: 'Jenny',    lastName: 'Mather',    phoneNumbers: []  }]",
    "url": "/doc/formn/5.x.x/doc/retrieving/joining.html",
    "relUrl": "/doc/retrieving/joining.html"
  },
  "21": {
    "id": "21",
    "title": "Limiting Columns",
    "content": "Limiting ColumnsIn the last section we pulled all Personrecords from the database, and we included all properties/columns in the query.  We canlimit the selected properties/columns using theFromAdapter.selectmethod, which optionally takes one or more property names.  Here’s how.const query: Select&amp;lt;Person&amp;gt; = dataContext  .from(Person, 'p')  .select('p.id', 'p.firstName');A few notes about the above query.  An alias, p, has been provided for Person.  Like SQL, an alias lets usreference People using a short-hand notation in other parts of the query,like when limiting the selected columns.  It also lets us disambiguate incases where the same table is joined in multiple times.  Aliasing isoptional; if no alias is provided then the table will be referenced bytable name (people in this case).  The primary key must be selected for every table referenced in the query,including any joined-in tables.  Here we’ve included p.id as part of theselect.  Each selected column takes the form &amp;lt;table-alias&amp;gt;.&amp;lt;property-name&amp;gt;.  Recallthat in our exampledatabase the primary key ofthe people table is personID, and in themodels section we opted to associatethat column with the Person.id property.  So, in the above query, we selectp.id, not p.personID.Full ExampleHere’s a full example, which can be found in the formn-example repository undersrc/retrieve/limit-columns.ts.import { inspect } from 'util';import { MySQLDataContext, ConnectionOptions, Select } from 'formn';import { Person } from '../entity/person.entity';async function main() {  const connOpts: ConnectionOptions = require('../../connections.json');  const dataContext = new MySQLDataContext();  try {    await dataContext.connect(connOpts);    // Only pull Person.id and Person.firstName.    const query: Select&amp;lt;Person&amp;gt; = dataContext      .from(Person, 'p')      .select('p.id', 'p.firstName');    console.log(query.toString());    const people: Person[] = await query      .execute();    console.log(inspect(people, {depth: null, compact: false}));    await dataContext.end();  }  catch(err) {    console.error(err);  }}main();Run it with ts-node.npx ts-node ./src/retrieve/limit-columns.tsThe output will looks similar to the following.SELECT  `p`.`personID` AS `p.id`,        `p`.`firstName` AS `p.firstName`FROM    `people` AS `p`[  Person {    id: 1,    firstName: 'Joe'  },  Person {    id: 2,    firstName: 'Rand'  },  Person {    id: 3,    firstName: 'Holly'  },  Person {    id: 4,    firstName: 'Jenny'  },  Person {    id: 5,    firstName: 'Mickey'  },  Person {    id: 6,    firstName: 'Abe'  }]",
    "url": "/doc/formn/5.x.x/doc/retrieving/limiting-columns.html",
    "relUrl": "/doc/retrieving/limiting-columns.html"
  },
  "22": {
    "id": "22",
    "title": "Models",
    "content": "ModelsWith Formn, queries deal with models, a.k.a. entities.  A Formn model is aTypeScript class that describes how an entity in code maps to a database table.This section covers defining models, and using Formn’s model generator togenerate models from an existing database schema.",
    "url": "/doc/formn/5.x.x/doc/models/",
    "relUrl": "/doc/models/"
  },
  "23": {
    "id": "23",
    "title": "Ordering",
    "content": "OrderingThe Select class has anorderBy method that’s usedto sort the query.  The method takes one or more objects, each with  a property string in the form &amp;lt;table-alias&amp;gt;.&amp;lt;property-name&amp;gt;, and  a dir (direction) that is one of ASC or DESC.For example, to sortPersonrecords by firstName then lastName:const query: Select&amp;lt;Person&amp;gt; = dataContext  .from(Person, 'p')  .select('p.id', 'p.firstName', 'p.lastName')  .orderBy(    {property: 'p.firstName', dir: 'DESC'},    {property: 'p.lastName',  dir: 'ASC'});The orderBymethod can also be passed one or more property strings, in which casethe direction is ASC.const query: Select&amp;lt;Person&amp;gt; = dataContext  .from(Person, 'p')  .select('p.id', 'p.firstName', 'p.lastName')  .orderBy('p.firstName', 'p.lastName');Full ExampleYou can find a full example in the formn-example repository.  It’s undersrc/retrieve/order.ts.import { inspect } from 'util';import { MySQLDataContext, ConnectionOptions, Select } from 'formn';import { Person } from '../entity/person.entity';async function main() {  const connOpts: ConnectionOptions = require('../../connections.json');  const dataContext = new MySQLDataContext();  try {    await dataContext.connect(connOpts);    // Order by first name then last name.    const query: Select&amp;lt;Person&amp;gt; = dataContext      .from(Person, 'p')      .select('p.id', 'p.firstName', 'p.lastName')      .orderBy(        {property: 'p.firstName', dir: 'DESC'},        {property: 'p.lastName',  dir: 'ASC'});    // Alternatively orderBy can take strings, in which case    // the direction is ASC.  E.g.:    // .orderBy('p.firstName', 'p.lastName');    console.log(query.toString());    const people: Person[] = await query      .execute();    console.log(inspect(people, {depth: null, compact: false}));    await dataContext.end();  }  catch(err) {    console.error(err);  }}main();Run it with ts-node.npx ts-node ./src/retrieve/order.tsOutput will looks something like this.SELECT  `p`.`personID` AS `p.id`,        `p`.`firstName` AS `p.firstName`,        `p`.`lastName` AS `p.lastName`FROM    `people` AS `p`ORDER BY `p`.`firstName` ASC, `p`.`lastName` ASC[  Person {    id: 3,    firstName: 'Holly',    lastName: 'Davis'  },  Person {    id: 4,    firstName: 'Jenny',    lastName: 'Mather'  },  Person {    id: 1,    firstName: 'Joe',    lastName: 'Shmo'  },  Person {    id: 2,    firstName: 'Rand',    lastName: 'AlThore'  }]",
    "url": "/doc/formn/5.x.x/doc/retrieving/ordering.html",
    "relUrl": "/doc/retrieving/ordering.html"
  },
  "24": {
    "id": "24",
    "title": "Relationships",
    "content": "RelationshipsIn the last section we defined a Personclass and went over the basic model decorators.  Within a model, properties canreference other models using one of Formn’s relationship decorators,OneToMany,OneToOne, orManyToOne.In the example database wecreated,there’s a one-to-many relationship between people and phone_numbers.  Let’screate a PhoneNumber class, then relate that class to Person.import { Table, Column } from 'formn';@Table({name: 'phone_numbers'})export class PhoneNumber {  @Column({name: 'phoneNumberID', isPrimary: true, isGenerated: true,    isNullable: false, sqlDataType: 'int'})  id: number;  @Column({name: 'personID', isNullable: false, sqlDataType: 'int'})  personId: number;  @Column({isNullable: false, maxLength: 255, sqlDataType: 'varchar'})  phoneNumber: string;  @Column({maxLength: 255, sqlDataType: 'varchar'})  type: string;}Each person in our database has one or more phone numbers, so we’ll use theOneToMany decorator in thePerson class.import { Table, Column, OneToMany } from 'formn';import { PhoneNumber } from './phone-number.entity';@Table({name: 'people'})export class Person {  @Column({name: 'personID', isPrimary: true, isGenerated: true, isNullable: false})  id: number;  // ...  // Other column definitions, as previously defined.  // ...  @OneToMany&amp;lt;Person, PhoneNumber&amp;gt;(() =&amp;gt; PhoneNumber, (p, pn) =&amp;gt; [p.id, pn.personId])  phoneNumbers: PhoneNumber[];}All of the relationshipdecorators–OneToMany,OneToOne, andManyToOne–are generic.  Theytake two type variables: the type of the local class, Person here, and thetype of the related class, in this case PhoneNumber.  In other words,@OneToMany&amp;lt;Person, PhoneNumber&amp;gt; is read, “One Person has manyPhoneNumbers.”Also, all of the relationship decorators have the same method signature (theytake the same arguments).  A function that returns the runtime type of the related class.  Above,PhoneNumber is the related class, so the first parameter is () =&amp;gt;PhoneNumber.  A function that returns an array describing how the two classes are relatedin the underlying database.  Formn uses this information behind the scenesto create joins between related tables.  In our example database, a foreignkey is defined on phone_numbers.personID, and it referencespeople.personID.  Both of those columns are aliased in our model classes,Person.id and PhoneNumber.personId.  So, given Person (p) andPhoneNumber (pn) instances, these two models are related as [p.id,pn.personId].Note that relationships can be composite (i.e. foreign keys can be defined onmultiple columns).  In that case, the second parameter should return an arrayof arrays:(left, right) =&amp;gt; [[left.prop1, right.relatedProp1], [left.prop2, right.relatedProp2], ...]We can also define the inverse relationship on the PhoneNumber class, as eachphone number belongs to a person.import { Table, Column, ManyToOne } from 'formn';import { Person } from './person.entity';@Table({name: 'phone_numbers'})export class PhoneNumber {  @Column({name: 'personID', isNullable: false})  personId: number;  // ...  // Other column definitions, as previously defined.  // ...  @ManyToOne&amp;lt;PhoneNumber, Person&amp;gt;(() =&amp;gt; Person, (pn, p) =&amp;gt; [pn.personId, p.id])  person: Person;}",
    "url": "/doc/formn/5.x.x/doc/models/relationships.html",
    "relUrl": "/doc/models/relationships.html"
  },
  "25": {
    "id": "25",
    "title": "Retrieving",
    "content": "RetrievingThis section covers selecting records from the database.  If you haven’talready done so, you should review the Getting Started,DataContext, and Models sections.",
    "url": "/doc/formn/5.x.x/doc/retrieving/",
    "relUrl": "/doc/retrieving/"
  },
  "26": {
    "id": "26",
    "title": "Transactions",
    "content": "TransactionsWhen you need to batch multiple CRUD operations together it’s generally donein a transaction.  This section covers transactions in Formn.  You should havea good grasp of the basics (Getting Started;DataContext; Models), as well as CRUDoperations (Creating; Retrieving;Updating; Deleting).Starting a TransactionTransactions are started with a call to theDataContext.beginTransactionmethod, supplying a function as the single argument.  That user-suppliedfunction  will be called with a newDataContext instance that’sbound to a single connection, and  must return a Promise.await dataContext  .beginTransaction(async (transDataContext: MySQLTransactionalDataContext): Promise&amp;lt;void&amp;gt; =&amp;gt; {    // Apply CRUD operations against transDataContext.  });Above, an asyncfunctionis supplied toDataContext.beginTransaction,so an implicit Promise is returned.  If the returned Promise is rejected(i.e. if an exception is raised) then the transaction will be automaticallyrolled back; otherwise, the transaction will be automatically committed.Transactions can also be be rolled back manually using theDataContext.rollbackTransactionmethod.Importantly, only operations performed against the transDataContext will bepart of the transaction; queries run against dataContext will not.Full Example: Replace PhoneNumbers for a PersonThere’s an example in the formn-example repository that uses transactions.  Itdeletes all thePhoneNumberrecords for aPerson,and then inserts two newPhoneNumbers.That example can be found undersrc/transaction/replace-phone-numbers.ts,and it’s repeated below for convenience.import { inspect } from 'util';import {  MySQLDataContext, ConnectionOptions, ConditionBuilder,  MySQLTransactionalDataContext, Delete, MutateResultType, Insert} from 'formn';import { PhoneNumber } from '../entity/phone-number.entity';async function main() {  const connOpts: ConnectionOptions = require('../../connections.json');  const dataContext = new MySQLDataContext();  try {    await dataContext.connect(connOpts);    // Start the transaction.    //    // Note that the supplied function (replacePhoneNumbers) is async, meaning    // that it implicitly returns a Promise instance.  If that promise is    // rejected (i.e. an exception occurs), then the transaction will be rolled    // back; otherwise, the transaction will be automatically committed.    await dataContext      .beginTransaction(replacePhoneNumbers);    await dataContext.end();  }  catch(err) {    console.error(err);  }}/** * Replace the phone numbers for a person. */async function replacePhoneNumbers(  transDataContext: MySQLTransactionalDataContext): Promise&amp;lt;void&amp;gt; {  // Delete all phone numbers for the person with ID 1.  const cb = new ConditionBuilder();  const qDelPhone: Delete = transDataContext    .from(PhoneNumber, 'pn')    .where(cb.eq('pn.personId', ':pid', 1))    .delete();  console.log(qDelPhone.toString());  const qDelPhoneRes: MutateResultType = await qDelPhone.execute();  console.log(inspect(qDelPhoneRes, {depth: null, compact: false}));  // Create two new phone numbers for the person with ID 1.  const phones = [new PhoneNumber(), new PhoneNumber()];  phones[0].personId    = 1;  phones[0].phoneNumber = '111-222-3333';  phones[0].type        = 'cell';  phones[1].personId    = 1;  phones[1].phoneNumber = '444-555-6666';  phones[1].type        = 'office';  // Insert each phone number, logging the SQL.  for (let i = 0; i &amp;lt; phones.length; ++i) {    const qInsPhone: Insert&amp;lt;PhoneNumber&amp;gt; = transDataContext      .insert(PhoneNumber, phones[i]);    console.log(qInsPhone.toString());    await qInsPhone.execute();    // An id will be set on the PhoneNumber instance.    console.log(inspect(phones[i], {depth: null, compact: false}));  }  // The transaction can be rolled back manually.  //await transDataContext.rollbackTransaction();}main();You can run the example with ts-node.npx ts-node ./src/transaction/replace-phone-numbers.tsOutput will look similar to the following.DELETE  `pn`FROM    `phone_numbers` AS `pn`WHERE   `pn`.`personID` = :pidResultSetHeader {  fieldCount: 0,  affectedRows: 3,  insertId: 0,  info: '',  serverStatus: 3,  warningStatus: 0}INSERT INTO `phone_numbers` (`personID`, `phoneNumber`, `type`)VALUES (:personId, :phoneNumber, :type)PhoneNumber {  personId: 1,  phoneNumber: '111-222-3333',  type: 'cell',  id: 5}INSERT INTO `phone_numbers` (`personID`, `phoneNumber`, `type`)VALUES (:personId, :phoneNumber, :type)PhoneNumber {  personId: 1,  phoneNumber: '444-555-6666',  type: 'office',  id: 6}",
    "url": "/doc/formn/5.x.x/doc/transactions/",
    "relUrl": "/doc/transactions/"
  },
  "27": {
    "id": "27",
    "title": "Tutorial Database Setup",
    "content": "Tutorial Database SetupAll of the example scripts presented in this documentation work against afictitious MySQL database that contains people and phone numbers.  If you wouldlike to follow along, you should create a formn_test_db database on a localMySQL server.Using DockerThe formn-example repositorycontains adocker-compose.yamlmanifest file that defines a database container.docker-compose up -dWith the container running, a MySQL instance will be accessible on port 3306.You can access the database for debugging purposes using the MySQL clientdirectly, or by executing mysql in the container.docker-compose exec db mysql -uformn-user -pformn-password -h127.0.0.1 formn_test_dbManual InitializationFirst, create the database.CREATE DATABASE formn_test_dbThen run the following SQL.  It creates a formn-user user, and initializesthe people and phone_numbers tables.GRANT SELECT, INSERT, UPDATE, DELETE  ON `formn_test_db`.* to 'formn-user'@'%'  IDENTIFIED BY 'formn-password';CREATE TABLE people (  personID INT NOT NULL PRIMARY KEY AUTO_INCREMENT,  firstName VARCHAR(255),  lastName VARCHAR(255),  createdOn TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP);INSERT INTO people (firstName, lastName) VALUES ('Joe', 'Shmo');INSERT INTO people (firstName, lastName) VALUES ('Rand', 'AlThore');INSERT INTO people (firstName, lastName) VALUES ('Holly', 'Davis');INSERT INTO people (firstName, lastName) VALUES ('Jenny', 'Mather');CREATE TABLE phone_numbers (  phoneNumberID INT NOT NULL PRIMARY KEY AUTO_INCREMENT,  phoneNumber VARCHAR(255) NOT NULL,  type VARCHAR(255),  personID INT NOT NULL,  CONSTRAINT fk__phone_numbers__personID__people    FOREIGN KEY (personID) REFERENCES people(personID)    ON DELETE CASCADE);INSERT INTO phone_numbers (personID, phoneNumber, type) VALUES (1, '530-307-8810', 'mobile');INSERT INTO phone_numbers (personID, phoneNumber, type) VALUES (1, '916-200-1440', 'home');INSERT INTO phone_numbers (personID, phoneNumber, type) VALUES (1, '916-293-4667', 'office');INSERT INTO phone_numbers (personID, phoneNumber, type) VALUES (2, '666-451-4412', 'mobile');",
    "url": "/doc/formn/5.x.x/doc/getting-started/tutorial-database-setup.html",
    "relUrl": "/doc/getting-started/tutorial-database-setup.html"
  },
  "28": {
    "id": "28",
    "title": "TypeScript Config",
    "content": "TypeScript ConfigFormn is intended for TypeScript projects that run on Node.js, and it requiresdecorators and decorator metadata to be enabled.  In your project, you’ll needto enable these configuration settings in yourtsconfig.jsonfile.  A typical, working tsconfig.json file is presented below.{  &quot;compilerOptions&quot;: {    &quot;target&quot;: &quot;es6&quot;,    &quot;module&quot;: &quot;commonjs&quot;,    &quot;noImplicitAny&quot;: true,    &quot;noImplicitThis&quot;: true,    &quot;strictPropertyInitialization&quot;: false,    &quot;emitDecoratorMetadata&quot;: true,    &quot;experimentalDecorators&quot;: true,    &quot;rootDir&quot;: &quot;./src&quot;,    &quot;outDir&quot;: &quot;./dist&quot;  },  &quot;include&quot;: [    &quot;src/**/*&quot;  ],  &quot;exclude&quot;: [    &quot;node_modules&quot;  ]}The tsconfig.json file should be placed at the root of your project.  In theabove example, the project’s code is expected to reside in the src directory,and the built code will be output to the dist folder.",
    "url": "/doc/formn/5.x.x/doc/getting-started/typescript-config.html",
    "relUrl": "/doc/getting-started/typescript-config.html"
  },
  "29": {
    "id": "29",
    "title": "Updating a Model",
    "content": "Updating a ModelA model is updating using theDataContext.updatemethod.  It taks two parameters:  An EntityType, which is someTable-decorated class.  (See theModels section.)  A model, which is an instance of theEntityType.  The model musthave at least the primary key set.DataContext.updatereturns an UpdateModelinstance, which is a type of Query.As such, you can use thetoString method fordebugging, and theexecute method to runthe query.Update a Person InstanceHere’s how one could update the firstName of aPersonrecord.// Update the first name of the person with ID 1.const person = new Person();person.id = 1;person.firstName = 'Marco';const query: UpdateModel&amp;lt;Person&amp;gt; = dataContext  .update(Person, person);console.log(query.toString());// If no rows are affected (i.e. if a person with an id of 1 does not// exist), then an error will be raised.await query.execute();In this case, we’ve only updated one property, firstName; all otherproperties are ignored.  It’s worth pointing out that Formn differentiatesbetween undefined and null.  In the above query, since person.lastName isundefined, Formn ignores it.  If it were null, however, Formn would set theassociated value to NULL in the database.Also note the final comment.  Updating a model is done by ID, and if the updatedoes not affect any rows then an error will be raised.  In the nextsection we’ll cover batch updates, which do not havethis restriction.Full ExampleThe example shown above is present in the formn-example repository undersrc/update/update-person.ts.import {  MySQLDataContext, ConnectionOptions, ConditionBuilder, UpdateModel} from 'formn';import { Person } from '../entity/person.entity';async function main() {  const connOpts: ConnectionOptions = require('../../connections.json');  const dataContext = new MySQLDataContext();  try {    await dataContext.connect(connOpts);    // Update the first name of the person with ID 1.    const person = new Person();    person.id = 1;    person.firstName = 'Marco';    const query: UpdateModel&amp;lt;Person&amp;gt; = dataContext      .update(Person, person);    console.log(query.toString());    // If no rows are affected (i.e. if a person with an id of 1 does not    // exist), then an error will be raised.    await query.execute();    await dataContext.end();  }  catch(err) {    console.error(err);  }}main();It can be run with ts-node.npx ts-node ./src/update/update-person.tsOutput will look like this.UPDATE  `people` AS `people`SET`people`.`firstName` = :people_firstName_0WHERE   (`people`.`personID` = :people_id_0)Again, note that only the firstName is updated, and the update is by ID.",
    "url": "/doc/formn/5.x.x/doc/updating/updating-a-model.html",
    "relUrl": "/doc/updating/updating-a-model.html"
  },
  "30": {
    "id": "30",
    "title": "Updating",
    "content": "UpdatingIn this part of the documentation we’ll cover updating records.  You should befamiliar with the basics introduced in the GettingStarted, DataContext, andModels sections.  There’s also some overlap with theRetrieving section.",
    "url": "/doc/formn/5.x.x/doc/updating/",
    "relUrl": "/doc/updating/"
  },
  "31": {
    "id": "31",
    "title": "Validation Classes",
    "content": "Validation ClassesThere are three built-in validation classes in Formn, each of which extends theModelValidator base class.  InsertModelValidator:Used to validate a model prior to inserting it.  UpdateModelValidator:Used to validate a model before updating by ID.  DeleteModelValidator:Used to validate a model before deleting by ID.All three classes work the same way: instantiate the class, then call thevalidate methodwith two arguments.  An object to validate.  This can be a plain JavaScript object, like anobject from an API request, or an instance of a class.  The constructor of a@Table-decorated class, a.k.a. an“Entity.”  The first parameter–the object–will be checked against theEntity’s metadata to ensure that it’s acceptable for the requested CRUDoperation.The validatemethod returns a Promise that is resolved if the object is valid, orotherwise rejected with an error describing why the object is invalid.In code terms, here’s how validation looks.import { InsertModelValidator } from 'formn';import { PhoneNumber } from '../entity/phone-number.entity';const validator = new InsertModelValidator();const phone = {  personId:    1,  phoneNumber: '530-222-3333',  type:        'mobile'};// Validate &quot;phone&quot; against the &quot;PhoneNumber&quot; entity, ensuring that &quot;phone&quot; can// be inserted.validator  .validate(phone, PhoneNumber)  .then(() =&amp;gt; console.log('Object is valid.'))  .catch(err =&amp;gt; console.error('Object is invalid: ', err));Column MetadataBack in the Models section, we defined aPhoneNumberclass and decorated each property with theColumn decorator.Column takes aColumnMetaOptions objectas an argument, which provides metadata about each property’s correspondingdatabase column, like the data type, maximum length, nullability, and so on.Let’s look more closely at the PhoneNumber.phoneNumber property.@Column({isNullable: false, maxLength: 255, sqlDataType: 'varchar'})@Validate(new PhoneValidator())phoneNumber: string;That given, Formn knows that the phoneNumber property must be a string, itmust not exceed 255 characters, and it cannot be null.  There’s also somecustom, user-defined validation provided by thebsy-validationpackage.  Namely, we’ve specified that the phoneNumber property should gothroughbsy-validation’sPhoneValidator.Next up, we’ll describe how the validation classeswork in detail, and look over some examples.",
    "url": "/doc/formn/5.x.x/doc/validation/validation-classes.html",
    "relUrl": "/doc/validation/validation-classes.html"
  },
  "32": {
    "id": "32",
    "title": "Validation Rules",
    "content": "Validation RulesIn the last section we gave an overview of Formn’sbuilt-in validation classes.  Obviously, validation differs between create,update, and delete operations.  For example, when inserting aPhoneNumberinstance, the phoneNumber property is required: it cannot be null; itcannot be undefined.  On the other hand, when updating aPhoneNumber,the phoneNumber property can be omitted: the user may want to updatepartially, e.g. just change the type.The specific validation rules for each operation are laid out below.  Each hasexamples which reference thePhoneNumberclass, shown here for convenience.import { Validate, PhoneValidator } from 'bsy-validation';import { Table, Column, ManyToOne } from 'formn';import { Person } from './person.entity';@Table({name: 'phone_numbers'})export class PhoneNumber {  @Column({name: 'personID', isNullable: false, sqlDataType: 'int'})  personId: number;  @Column({isNullable: false, maxLength: 255, sqlDataType: 'varchar'})  @Validate(new PhoneValidator())  phoneNumber: string;  @Column({name: 'phoneNumberID', isPrimary: true, isGenerated: true,    isNullable: false, sqlDataType: 'int'})  id: number;  @Column({maxLength: 255, sqlDataType: 'varchar'})  type: string;  @ManyToOne&amp;lt;PhoneNumber, Person&amp;gt;(() =&amp;gt; Person, (l, r) =&amp;gt; [l.personId, r.id])  person: Person;}InsertModelValidatorUse this class before inserting records.  Values associated with generated columns must not be defined.  For example,PhoneNumber.id cannot be manually set because it’s associated with anauto-incrementing primary key column.  If a column is not nullable and does not have a default value, the associatedvalue must be defined.  If the object passes steps 1 and 2, the ModelValidator rules are applied(see below).The following object is not a validPhoneNumberobject because:  id is associated with a generated column, and thus cannot be defined.  phoneNumber and personId correspond to non-nullable columns, so theymust be defined.const phone = {  id: 1};UpdateModelValidatorUse this class prior to updating a model by ID.  The property or properties associated with the primary key column(s) must bedefined and cannot be null.  If the object passes step 1, the ModelValidator rules are applied(see below).The below object is not a validPhoneNumberobject because:  id is not defined.const phone = {  personId: 42,  type: 'mobile',  phoneNumber: '530-222-3333'};DeleteModelValidatorUse this class prior to deleting a model by ID.  The property or properties associated with the primary key column(s) must bedefined and cannot be null.No other validation is applied.The following PhoneNumberobject cannot be deleted because:  id is not defined.const phone = {};Conversely, the following passes validation even though phoneNumber is invalid, becase:  id is defined and valid.const phone = {  id: 1,  phoneNumber: 'invalid phone number'};ModelValidator (The Base Class)This class is mainly used internally by the above validators.  It could beuseful in certain scenarios, such as making a custom model validator.  The data type of each value is validated.          For strings, the maximum length is validated.        Values corresponding to non-nullable columns must not be null.  Custom validation rules are applied, such as the PhoneValidator checkdescribed above.The followingPhoneNumberobject cannot be inserted because:  personId has an invalid data type (not an integer).  type has an invalid data type (not a string).const phone = {  personId: 3.14,  type: false};ThisPhoneNumberobject cannot be updated because:  phoneNumber is not a valid phone number.const phone = {  id: 1,  phoneNumber: 'bad phone number'};Full ExampleEach of the example objects presented above is taken from the validationdirectoryof the formn-example repository.  One of the examples,src/validation/insert/generated-column-defined.ts,is shown below.import { InsertModelValidator } from 'formn';import { PhoneNumber } from '../../entity/phone-number.entity';const validator = new InsertModelValidator();// &quot;id&quot; cannot be defined because it's generated (an auto-incrementing// primary key).//// &quot;phoneNumber&quot; and &quot;personId&quot; are non-nullable, so they must be defined.const phone = {  id: 1};validator  .validate(phone, PhoneNumber)  .catch(err =&amp;gt; console.error(JSON.stringify(err, null, 2)));Run it using ts-node.npx ts-node src/validation/insert/generated-column-defined.tsHere’s the output, which is an Error of typeValidationErrorList.{  &quot;code&quot;: &quot;VAL_ERROR_LIST&quot;,  &quot;name&quot;: &quot;ValidationErrorList&quot;,  &quot;detail&quot;: &quot;Validation errors occurred.&quot;,  &quot;errors&quot;: [    {      &quot;code&quot;: &quot;VALIDATION_ERROR&quot;,      &quot;name&quot;: &quot;ValidationError&quot;,      &quot;detail&quot;: &quot; &quot;id &quot; must not be defined.&quot;,      &quot;field&quot;: &quot;id&quot;    },    {      &quot;code&quot;: &quot;VALIDATION_ERROR&quot;,      &quot;name&quot;: &quot;ValidationError&quot;,      &quot;detail&quot;: &quot; &quot;phoneNumber &quot; must be defined.&quot;,      &quot;field&quot;: &quot;phoneNumber&quot;    },    {      &quot;code&quot;: &quot;VALIDATION_ERROR&quot;,      &quot;name&quot;: &quot;ValidationError&quot;,      &quot;detail&quot;: &quot; &quot;personId &quot; must be defined.&quot;,      &quot;field&quot;: &quot;personId&quot;    }  ]}",
    "url": "/doc/formn/5.x.x/doc/validation/validation-rules.html",
    "relUrl": "/doc/validation/validation-rules.html"
  },
  "33": {
    "id": "33",
    "title": "Validation",
    "content": "ValidationFormn offers some built-in validation classes that can be used prior toinserting, updating, or deleteing records.  These classes build on top of thebsy-validationpackage, which provides decorator-based validation, and is extendable.Formn models (see the Models section) have a good deal of columnmetadata that’s provided using theColumn decorator.  This metadataincludes data type, nullability, max length requirements, and so on.  With thatmetadata, Formn can verify that user-provided models meet the criteria neededto insert, update, or delete records.  For example, if a database table has aphoneNumber VARCHAR(255) NOT NULL column, a corresponding Formn model cannotbe inserted if the phoneNumber property is null, undefined, not astring, or exceeds 255 characters.  But when updating, the validation rulesdiffer: phoneNumber doesn’t have to be defined.These metadata verifications, coupledwith bsy-validation,provide an extensive validation suite.",
    "url": "/doc/formn/5.x.x/doc/validation/",
    "relUrl": "/doc/validation/"
  }
}
